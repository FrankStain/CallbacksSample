## Пример реализации идиомы "Обратный вызов" (или Callback).


#### Пролог.

В основе этого кода лежит изначальное предположение о том, чтобы попробовать свести вызов любой функции, или функтора, к вызову глобальной функции.
Как это сделать? Сделать это, одновременно, и просто, и не просто.

На выходе мы хотим получить указатель на глобальную функцию, обращение к которой так или иначе привело бы к вызову целевой функции, метода или функтора.
Получение такого указателя на функцию позволяет значительно упростить логику работы `делегатов` и `обратного вызова`.

Звучит, в целом, заманчиво для того, чтобы попробовать реализовать хотя бы прототип.


#### Анализ.

Подпрограмма сегодня может быть иметь одну из следующих форм:

- Глобальные функции и статические функции классов.
- Методы объектов всех разновидностей.
- Лямбда-выражения и функциональные объекты.

Каким образом можно получить глобальную функцию, которая бы внутри себя вызывала переданную в нее подпрограмму? Очевидно, что такая функция должна получаться
из шаблона функции. Под вопросом остается лишь то, что нужно указать в аргументах инстанцирования такого шаблона?


###### Глобальные функции.

Тип указателя на глобальную функцию можно описать следующим шаблоном.

```.cpp
template< typename TResult, typename... TArguments >
using GlobalFunctionPointer = TResult (*)( TArguments... );
```

В категорию глобальных функций придется записать и статические функции классов, за тип их указателя.

И, вроде бы, указатель на статическую функцию класса или глобальную функцию не нуждается в оборачивании, т.к. итак из себя представляет глобальную функцию,
но завернуть их все равно стоит для того, чтобы гарантировать единообразие типа указателя на требуемую для нас глобальную функцию.

В стандарте C++17 шаблон такой функции-обертки можно попробовать объявить так:

```.cpp
template< auto FUNCTION, typename TResult, typename... TArguments >
TResult GlobalFunctionWrap( TArguments... );
```

Но такое объявление не выглядит удобным и позволяет допустить ошибку несоответствия типов между переданной `FUNCTION` и аргументами шаблона `GlobalFunctionWrap`.
Поэтому шаблон такой функции нужно объявить внутри другого шаблона.

```.cpp
template< typename TResult, typename... TArguments >
struct GlobalFunctionWrapper final
{
	template<TResult (*FUNCTION)( TArguments... )>
	static TResult Wrap( TArguments... );
};
```

Такой шаблон позволяет полноценно обернуть другую функцию в свою. Это полезно тем, что теперь `Wrap` можно изменять под нужды дальнейшего использования.
А изменить ее еще придется, чтобы привести сигнатуры всех `Wrap` к одному типу функции.


###### Методы.

Любой метод можно выразить через один из приведенных ниже шаблонов.

```.cpp
template< typename THost, typename TResult, typename... TArguments >
using MemberFunctionPointer = TResult (THost::*)( TArguments... );
```

Конкретно данный шаблон описывает только набор методов на обычном контексте объекта. Другой контекст можно описать добавлением к этому шаблону разных комбинаций
спецификаторов и модификаторов: `&`, `&&`, `const` и `volatile`. Для анализа достаточно рассмотреть только обычный контекст.

По аналогии с глобальной функцией, обертку метода тоже лучше реализовать через два шаблона.

```.cpp
template< typename THost, typename TResult, typename... TArguments >
struct MemberFunctionWrapper final
{
	template<TResult (THost::*FUNCTION)( TArguments... )>
	static TResult Wrap( void* const, TArguments... );
};
```

Для вызова метода нужна инстанция объекта, в контексте которого метод и будет вызван. Запомнить через параметры шаблона мы эту инстанцию не можем.
Но мы можем передать объект для вызова метода в качестве одного из аргументов для вызова функции-обертки, самым первым аргументом.
Было бы очень удобно объявить такой параметр как `THost&`, сразу определяя его семантику и требования. Но такое объявление не подходит тогда, когда стоит задача
обеспечить единообразие сигнатур `Wrap` для методов и глобальных функций. Поэтому первый аргумент определен как `void* const`, подразумевая и то, что туда
может быть передан `nullptr` в случае с оберткой глобальной функции.


###### Функциональные объекты.

Функциональные объекты отличаются от функций тем, что являются в первую очередь именно объектами. "Функциональность" такого объекта выражается в наличии у него
перегрузки оператора `operator()`, которой можно воспользоваться, обратившись к объекту по ссылке как к функции.
Примечательно и то, что перегрузка `operator()` не может быть объявлена снаружи класса. Это значит, что `operator()` всегда является методом объекта.

Следовательно, справедливым будет то, что все функциональные объекты можно свести к случаю методов и особого отдельного рассмотрения здесь не требуется.
Просто `Wrap` будет запоминать указатель на `operator()` функционального объекта, а сам объект будет передаваться все также первым параметром при вызове.

Такой механизм подходит даже для лямбда-функций, чей `operator()`, в общем случае, имеет константный контекст или обычный контекст для случая `mutable` функции.
Для лямбда-функций можно сделать только оптимизацию по памяти, отказавшись хранить инстанцию функции с пустым замыканием.


#### Реализация.

Реализация такого обратного вызова должна уметь приводить указатели на переданные функции к единому типу указателя на глобальную функцию.
Такое требование означает адаптацию. Соответственно для реализации следует воспользоваться идиомой *Адаптер*.

Суть адаптера в том, чтобы набор частных случаев свести к интерфейсу общей формы. В ходе анализа было выявлено всего три уникальных случая, которые требуется
адаптировать к единому интерфейсу обратного вызова:

- указатель на глобальную функцию и указатель на статическую функцию класса;
- указатель на метод класса;
- лямбда-функция без замыкания (пустая).

Для каждого из случаев требуется создать свой адаптер, приводящий функцию конкретного случая к общему интерфейсу указателя на глобальную функцию.

Адаптеры `GlobalFunctionContext`, `MemberFunctionContext` и `EmptyLambdaContext` выполняют такое приведение.
Шаблон функции `AdaptedCall` после инстанцирования во всех трех случаях сводится к единому типу указателя на функцию.
Первый параметр используется для передачи контекста вызова метода, коим является объект, для которого метод вызывается. В двух других случаях первый
параметр не учитывается за ненадобностью.

В качестве контекста в обратном вызове выступает или замыкание лямбда-функции, или объект для вызова метода. Хранение этих двух контекстов отличается между собой.
Рядовым случаем для лямбда-функции является передача ее по значение в место ее вызова. Это значит что нормой для обратного вызова должно быть владение переданной
лямбда-функцией. Объект же, наоборот, обычно передается по ссылке/указателю без права владения на принимающей стороне.

Это означает что реализация обратного вызова должна уметь как владеть переданным контекстом, так и допускать передачу контекста без владения.
Попутно еще возникает вопрос копирования или клонирования контекста в том случае, когда обратный вызов копируется или переносится.
В данном примере копирование владеемого контекста не рассматривается, взамен этого допускается совместное владение контекстом.
В качестве реализации такого механизма решено использовать `std::shared_ptr`, который лучше всего покрывает потребности обратного вызова в плане владения и
передачи контекста. Реализация `std::shared_ptr` позволяет как правильное хранение и удаление объекта после приведения указателя к общей форме,
так и легкий способ реализовать невладеющее совместное хранение.

В результате, обратный вызов реализуется как пара из указателя (`routine`) на глобальную функцию адаптера и `std::shared_ptr<void>` (`context`).
А исполнение обратного вызова условно реализуется как `return routine( context.get(), std::forward<TArguments>( arguments )... );`.
Такая реализация максимально упрощает сам обратный вызов, сводя его к состоянию максимально тонкой прослойки до вызываемой функции, а сам обратный вызов, по 
своей сути, становится легковесным Value Object-ом.

Для большего удобства получения обратного вызова в пример были введены три шаблона фабричных функций (`GetCallback`), по количеству форм переданной подпрограммы.
Каждый шаблон имеет свой контракт применения: для глобальных функций и статических функций класса, для методов и для функциональных объектов.
Для облегчения приведения типа переданной функции в тип обратного вызова был создан шаблон `SignatureSelector`, позволяющий правильно выбрать подходящую 
сигнатуру обратного вызова для типа переданной функции, а также шаблоны `FunctionSignature` и `FunctorSignature`, декорирующие работу с `SignatureSelector`.
Выбор правильной перегрузки шаблона `GetCallback` производится через SFINAE, для обеспечения работы которых были реализованы типовые черты:

- `IsGlobalFunction` чтобы отличить указатель на глобальную функцию от прочих (константа `IS_GLOBAL_FUNCTION`);
- `IsMemberFunction` чтобы отличить указатель на метод от прочих и проверить принадлежность метода к интерфейсу класса контекста (константа `IS_MEMBER_FUNCTION`);
- `IsFunctor` чтобы отличить тип функционального объекта от прочих (константа `IS_FUNCTOR`).

Эти черты позволяют правильно отличать варианты переданной в `GetCallback` и включать правильную перегрузку для преобразования переданных аргументов 
в обратный вызов.


#### Сборка и проверка.
			  
Сборка этого кода проводилась в MS Visual Studio 2019. Попутно этот код проверялся на Clang 15 и GCC 12.2.
Проблем в сборке или работе выявлено не было. Этот код написан в стандарте C++17 и по праву может считаться кросс-платформенным.
Запуск этого кода проводился также в VS2019, а попутно и в Clang 15 с GCC 12.2.

Проект для VS19 находится в папке `./project`. Исходный код расположен в папке `./source`.


#### Используемая в работе информация.

Реализация этого прототипа является компиляцией моего личного опыта и полный список используемой литературы привести практически невозможно.
Однако, некоторые важные источники информации, все-таки, я приведу.

- [Wiki: обратный вызов](https://ru.wikipedia.org/wiki/Callback_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5))
- [Wiki: делегат](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BB%D0%B5%D0%B3%D0%B0%D1%82_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5))
- [Wiki: событие](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B5_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5))
- [Библиотека <type_traits> С++](https://en.cppreference.com/w/cpp/header/type_traits)
- [Документация SFINAE](https://en.cppreference.com/w/cpp/language/sfinae)


#### Лицензия.

Этот код лицензируется по правилам MIT лицензии. Подробности есть в файле лицензии.

Основной репозиторий этого кода: https://github.com/FrankStain/CallbacksSample
